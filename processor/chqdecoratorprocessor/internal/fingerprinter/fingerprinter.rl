// Copyright 2024 CardinalHQ, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:generate ragel -Z -G2 fingerprinter.rl -o fingerprinter.go
//go:generate sed -i "1s|.*|// Code generated by ragel. DO NOT EDIT.|" fingerprinter.go

// nolint

package fingerprinter

import (
    "fmt"
    "strings"

    "github.com/cespare/xxhash/v2"
    "github.com/db47h/ragel/v2"
)

// Token types
const (
    TokenIdentifier ragel.Token = iota
    TokenString
    TokenUrl
    TokenDuration
    TokenDate
    TokenTime
    TokenNumber
    TokenLoglevel
    TokenIPv4
    TokenHTTPMethod
    TokenUUID
    TokenEmail
    TokenPath
    TokenFQDN
)

var TokenNames = map[ragel.Token]string{
    TokenIdentifier:  "Identifier",
    TokenString:      "String",
    TokenUrl:         "Url",
    TokenDuration:    "Duration",
    TokenDate:        "Date",
    TokenTime:        "Time",
    TokenNumber:      "Number",
    TokenLoglevel:    "Loglevel",
    TokenIPv4:        "IPv4",
    TokenHTTPMethod:  "HTTPMethod",
    TokenUUID:        "UUID",
    TokenEmail:       "Email",
    TokenPath:        "Path",
    TokenFQDN:        "FQDN",
}

type Fingerprinter interface {
    TokenString(t ragel.Token) string
    IsWord(word string) bool
    Fingerprint(input string) (fingerprint int64, level string)
}


type fingerprinterImpl struct {
    wordlist map[string]bool
}

// make golangci-lint happy
var (
    _ = fingerprinter_en_main
    _ = fingerprinter_error
)

func (*fingerprinterImpl) TokenString(t ragel.Token) string {
    if t < 0 || t >= ragel.Token(len(TokenNames)) {
        return "Token(" + fmt.Sprintf("%d", t) + ")"
    }
    return TokenNames[t]
}

// ragel state machine definition.
%%{
    machine fingerprinter;

    # utf-8 support
    include UTF8 "utf8.rl";

    newline = '\n' @{ s.Newline(p) };

    main := |*
        alpha_u = uletter | '_';
        alnum_u = alpha_u | digit;

        number = digit+ ('.' digit+)? | '.' digit+ | digit + '.';

        ansicode = digit+ (';' digit+)*  uletter;

        uuid = xdigit{8} [_\-] (xdigit{4} [_\-]){3} xdigit{12};

        dnslabel = alnum_u+ ('-' alnum_u+)*;
        fqdn = dnslabel ('.' dnslabel)+;
        email = alnum_u+ (('.' | '-' | '+' | '_') alnum_u+)* '@' fqdn;

        path = ('/'{1} alnum_u+)+ '/'{0,1};

        durationIdentifier =
            'ns' | 'nano' | 'nanosecond' 
            | 'us' | 'micro' | 'microsecond'
            | 'ms' | 'mil' | 'mils' | 'milli' | 'millis' | 'millisecond' | 'milliseconds'
            | 's' | 'sec' | 'secs' | 'second' | 'seconds'
            | 'min' | 'mins' | 'minute' | 'minutes'
            | 'hour' | 'hours'
            | 'day' | 'days'
            | 'week' | 'weeks'
            | 'mon' | 'month' | 'months'
            | 'year' | 'years';
        duration = digit+ space* durationIdentifier ('s' | '(s)')?;

        ipv4 = digit{1,3} '.' digit{1,3} '.' digit{1,3} '.' digit{1,3};

        protocol = alnum_u+;
        url_creds = (alnum_u+)? ':' (alnum_u+)? '@';
        url_path = ('/' alnum_u+)*;
        url_host = fqdn | ipv4;
        url_port = ':' digit{1,5};
        url = protocol '://' (url_creds)? url_host? url_port? url_path;
        httpmethod = 'get' | 'post' | 'put' | 'delete' | 'head' | 'patch';

        logLevels = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal' | 'panic';

        brackets = '(' | ')' | '[' | ']' | '{' | '}' | '<' | '>';
        punctuation = '.' | ',' | ';' | ':' | '!' | '?' | '"' | '\'' | '*' | '-' | '_' | '@' | '#' | '$' | '%' | '&' | '^' | '|' | '~' | '`' | '+' | '=' | '\\' | '|';
        skipcharacters = space | newline | cntrl | 0x7f | brackets |  punctuation;

        dateyear = digit{4} | digit{2};
        datemonth = digit{2} | 'jan' | 'feb' | 'mar' | 'apr' | 'may' | 'jun' | 'jul' | 'aug' | 'sep' | 'oct' | 'nov' | 'dec';
        dateday = digit{2};
        datesep = '-' | '/';

        date = dateyear datesep datemonth datesep dateday;
        timesep = ':' | '.';
        time = digit{2} timesep digit{2} timesep digit{2} (('.' | ',') digit{1,9})?;
    
        wordEndOfSentence = [a-zA-Z]+ '. ';

        identifier = alnum_u+ (('_' | '.' | '-' | '@')+ alnum_u*)+;

        # pre-filtering
        ansicode;

        path {
            s.Emit(ts, TokenPath, string(data[ts:te]))
        };

        ipv4 {
            s.Emit(ts, TokenIPv4, string(data[ts:te]))
        };

        uuid {
            s.Emit(ts, TokenUUID, string(data[ts:te]))
        };

        url {
            s.Emit(ts, TokenUrl, string(data[ts:te]))
        };

        email {
            s.Emit(ts, TokenEmail, string(data[ts:te]))
        };

        fqdn {
            s.Emit(ts, TokenFQDN, string(data[ts:te]))
        };

        time {
            s.Emit(ts, TokenTime, string(data[ts:te]))
        };

        date {
            s.Emit(ts, TokenDate, string(data[ts:te]))
        };

        duration {
            s.Emit(ts, TokenDuration, string(data[ts:te]))
        };

        number {
            s.Emit(ts, TokenNumber, string(data[ts:te]))
        };

        logLevels {
            s.Emit(ts, TokenLoglevel, string(data[ts:te]))
        };

        httpmethod {
            s.Emit(ts, TokenHTTPMethod, string(data[ts:te]))
        };

        wordEndOfSentence {
            s.Emit(ts, TokenString, string(data[ts:te]))
        };

        identifier {
            s.Emit(ts, TokenIdentifier, string(data[ts:te]))
        };

        alpha_u alnum_u* {
            s.Emit(ts, TokenString, string(data[ts:te]))
        };

        skipcharacters+;

        '/';
    *|;
}%%

%%write data nofinal;

func NewFingerprinter() *fingerprinterImpl {
    fp := fingerprinterImpl{
        wordlist: make(map[string]bool),
    }
    for _, word := range englishWords {
        fp.wordlist[word] = true
    }
    return &fp
}

func (fingerprinterImpl) Init(s *ragel.State) (int, int) {
    var cs, ts, te, act int
    %%write init;
    s.SaveVars(cs, ts, te, act)
    return %%{ write start; }%%, %%{ write error; }%%
}

func (fingerprinterImpl) Run(s *ragel.State, p, pe, eof int) (int, int) {
    cs, ts, te, act, data := s.GetVars()
    %%write exec;
    s.SaveVars(cs, ts, te, act)
    return p, pe
}

func (fp *fingerprinterImpl) Fingerprint(input string) (fingerprint int64, level string) {
	l := strings.TrimSpace(input)
	l = strings.ToLower(l)
	s, level := fp.tokenize(l)
	return int64(xxhash.Sum64String(s)), level
}

func (fp *fingerprinterImpl) IsWord(word string) bool {
    return fp.wordlist[word]
}

func (fp *fingerprinterImpl) tokenize(input string) (string, string) {
	s := ragel.New("test", strings.NewReader(input), fp)
	items := []string{}
	level := ""
	for {
		_, tok, literal := s.Next()
		switch tok {
		case ragel.EOF:
			return strings.Join(items, " "), level
		case ragel.Error:
		// TODO should increment a counter here...
		case TokenLoglevel:
			level = literal
		case TokenString:
            if fp.wordlist[literal] {
                items = append(items, literal)
            }
		default:
			items = append(items, "<"+fp.TokenString(tok)+">")
		}
	}
}

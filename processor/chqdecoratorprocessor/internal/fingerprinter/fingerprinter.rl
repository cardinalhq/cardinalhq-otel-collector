// Copyright 2024 CardinalHQ, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:generate ragel -Z -G2 fingerprinter.rl -o fingerprinter.go
//go:generate sed -i "1s|.*|// Code generated by ragel. DO NOT EDIT.|" fingerprinter.go

// nolint

package fingerprinter

import (
    "fmt"
    "strings"
    "unicode"

    "github.com/cespare/xxhash/v2"
    "github.com/db47h/ragel/v2"
)

// Token types
const (
    TokenIdentifier ragel.Token = iota
    TokenString
    TokenUrl
    TokenDuration
    TokenDate
    TokenTime
    TokenNumber
    TokenLoglevel
    TokenIPv4
    TokenHTTPMethod
    TokenUUID
    TokenEmail
    TokenPath
    TokenFQDN
)

var TokenNames = map[ragel.Token]string{
    TokenIdentifier:  "Identifier",
    TokenString:      "String",
    TokenUrl:         "Url",
    TokenDuration:    "Duration",
    TokenDate:        "Date",
    TokenTime:        "Time",
    TokenNumber:      "Number",
    TokenLoglevel:    "Loglevel",
    TokenIPv4:        "IPv4",
    TokenHTTPMethod:  "HTTPMethod",
    TokenUUID:        "UUID",
    TokenEmail:       "Email",
    TokenPath:        "Path",
    TokenFQDN:        "FQDN",
}

type Fingerprinter interface {
    TokenString(t ragel.Token) string
    IsWord(word string) bool
    Fingerprint(input string) (fingerprint int64, level string, err error)
    Tokenize(input string) (string, string, error)
}


type fingerprinterImpl struct {
    wordlist map[string]bool
}

// make golangci-lint happy
var (
    _ = fingerprinter_en_main
    _ = fingerprinter_error
)

func (*fingerprinterImpl) TokenString(t ragel.Token) string {
    if t < 0 || t >= ragel.Token(len(TokenNames)) {
        return "Token(" + fmt.Sprintf("%d", t) + ")"
    }
    return TokenNames[t]
}

// ragel state machine definition.
%%{
    machine fingerprinter;

    # utf-8 support
    include UTF8 "utf8.rl";

    newline = '\n' @{ s.Newline(p) };

    main := |*
        alpha_u = uletter | '_';
        alnum_u = alpha_u | digit;

        number = digit+ ('.' digit+)? | '.' digit+ | digit + '.';

        ansicode = digit+ (';' digit+)*  uletter;

        uuid = xdigit{8} [_\-] (xdigit{4} [_\-]){3} xdigit{12};

        dnslabel = alnum_u+ ('-' alnum_u+)*;
        fqdn = dnslabel ('.' dnslabel)+;
        email = alnum_u+ (('.' | '-' | '+' | '_') alnum_u+)* '@' fqdn;

        path = ('/'{1} alnum_u+)+ '/'{0,1};

        durationIdentifier =
            [Nn][Ss] | [Nn] 'ano' | [Nn] 'nano' [Ss] 'econd' 
            | 'us' | 'micro' | 'microsecond'
            | 'ms' | 'mil' | 'mils' | 'milli' | 'millis' | 'millisecond' | 'milliseconds'
            | 's' | 'sec' | 'secs' | 'second' | 'seconds'
            | 'min' | 'mins' | 'minute' | 'minutes'
            | 'hour' | 'hours'
            | 'day' | 'days'
            | 'week' | 'weeks'
            | 'mon' | 'month' | 'months'
            | 'year' | 'years';
        duration = digit+ space* durationIdentifier ('s' | '(s)')?;

        ipv4 = digit{1,3} '.' digit{1,3} '.' digit{1,3} '.' digit{1,3};

        protocol = alnum_u+;
        url_creds = (alnum_u+)? ':' (alnum_u+)? '@';
        url_path = ('/' alnum_u+)*;
        url_host = fqdn | ipv4;
        url_port = ':' digit{1,5};
        url = protocol '://' (url_creds)? url_host? url_port? url_path;
        httpmethod = [Gg][Ee][Tt] | [Pp][Oo][Ss][Tt] | [Pp][Uu][Tt] | [Dd][Ee][Ll][Ee][Tt][Ee] | [Hh][Ee][Aa][Dd] | [Pp][Aa][Tt][Cc][Hh];

        logLevels = [Tt][Rr][Aa][Cc][Ee] | [Dd][Ee][Bb][Uu][Gg] | [Ii][Nn][Ff][Oo] | [Ww][Aa][Rr][Nn] | [Ee][Rr][Rr][Oo][Rr] | [Ff][Aa][Tt][Aa][Ll] | [Pp][Aa][Nn][Ii][Cc];

        brackets = '(' | ')' | '[' | ']' | '{' | '}' | '<' | '>';
        punctuation = '.' | ',' | ';' | ':' | '!' | '?' | '"' | '\'' | '*' | '-' | '_' | '@' | '#' | '$' | '%' | '&' | '^' | '|' | '~' | '`' | '+' | '=' | '\\' | '|';
        skipcharacters = space | newline | cntrl | 0x7f | brackets |  punctuation;

        dateyear = digit{4} | digit{2};
        datemonth = digit{2} | 'jan' | 'feb' | 'mar' | 'apr' | 'may' | 'jun' | 'jul' | 'aug' | 'sep' | 'oct' | 'nov' | 'dec';
        dateday = digit{2};
        datesep = '-' | '/';

        date = dateyear datesep datemonth datesep dateday;
        timesep = ':' | '.';
        time = digit{2} timesep digit{2} timesep digit{2} (('.' | ',') digit{1,9})?;
    
        wordEndOfSentence = [a-zA-Z]+ '. ';

        identifier = alnum_u+ (('_' | '.' | '-' | '@')+ alnum_u*)+;

        # pre-filtering
        ansicode;

        path {
            s.Emit(ts, TokenPath, string(data[ts:te]))
        };

        ipv4 {
            s.Emit(ts, TokenIPv4, string(data[ts:te]))
        };

        uuid {
            s.Emit(ts, TokenUUID, string(data[ts:te]))
        };

        url {
            s.Emit(ts, TokenUrl, string(data[ts:te]))
        };

        email {
            s.Emit(ts, TokenEmail, string(data[ts:te]))
        };

        fqdn {
            s.Emit(ts, TokenFQDN, string(data[ts:te]))
        };

        time {
            s.Emit(ts, TokenTime, string(data[ts:te]))
        };

        date {
            s.Emit(ts, TokenDate, string(data[ts:te]))
        };

        duration {
            s.Emit(ts, TokenDuration, string(data[ts:te]))
        };

        number {
            s.Emit(ts, TokenNumber, string(data[ts:te]))
        };

        logLevels {
            s.Emit(ts, TokenLoglevel, string(data[ts:te]))
        };

        httpmethod {
            s.Emit(ts, TokenHTTPMethod, string(data[ts:te]))
        };

        wordEndOfSentence {
            s.Emit(ts, TokenString, string(data[ts:te]))
        };

        identifier {
            s.Emit(ts, TokenIdentifier, string(data[ts:te]))
        };

        alpha_u alnum_u* {
            s.Emit(ts, TokenString, string(data[ts:te]))
        };

        skipcharacters+;

        '/';
    *|;
}%%

%%write data nofinal;

func NewFingerprinter() *fingerprinterImpl {
    fp := fingerprinterImpl{
        wordlist: make(map[string]bool),
    }
    for _, word := range englishWords {
        fp.wordlist[word] = true
    }
    return &fp
}

func (fingerprinterImpl) Init(s *ragel.State) (int, int) {
    var cs, ts, te, act int
    %%write init;
    s.SaveVars(cs, ts, te, act)
    return %%{ write start; }%%, %%{ write error; }%%
}

func (fingerprinterImpl) Run(s *ragel.State, p, pe, eof int) (int, int) {
    cs, ts, te, act, data := s.GetVars()
    %%write exec;
    s.SaveVars(cs, ts, te, act)
    return p, pe
}

func (fp *fingerprinterImpl) Fingerprint(input string) (fingerprint int64, level string, err error) {
	l := strings.TrimSpace(input)
	l = strings.ToLower(l)
	s, level, err := fp.Tokenize(l)
    if err != nil {
        return 0, "", err
    }
	return int64(xxhash.Sum64String(s)), level, nil
}

func (fp *fingerprinterImpl) IsWord(word string) bool {
    if _, ok := fp.wordlist[word]; ok {
        return true
    }
    // If the word is entirely uppercase or entirely lowercase, it needs to fully match.
    if strings.ToUpper(word) == word || strings.ToLower(word) == word {
        return false
    }
    words := splitWords(word)
    wordcount := 0
    for _, w := range words {
        if _, ok := fp.wordlist[w]; ok {
            wordcount++
        }
    }
    return wordcount == len(words)
}

func (fp *fingerprinterImpl) Tokenize(input string) (string, string, error) {
	s := ragel.New("test", strings.NewReader(input), fp)
	items := []string{}
	level := ""
	for {
		_, tok, literal := s.Next()
		switch tok {
		case ragel.EOF:
			return strings.Join(items, " "), strings.ToLower(level), nil
		case ragel.Error:
            return "", "", fmt.Errorf("error: %s", literal)
		case TokenLoglevel:
            if level == "" {
    			level = literal
                items = append(items, "<Loglevel>")
            } else {
                items = append(items, strings.ToLower(literal))
            }
		case TokenString:
            if fp.IsWord(literal) {
                items = append(items, strings.ToLower(literal))
            }
		default:
			items = append(items, "<"+fp.TokenString(tok)+">")
		}
	}
}

func splitWords(input string) []string {
    var result []string
    var word strings.Builder

    for i, r := range input {
        // Check if the character is uppercase
        if unicode.IsUpper(r) {
            // If it's not the first character and the previous character is not an underscore,
            // it indicates the start of a new word
            if i != 0 && input[i-1] != '_' {
                result = append(result, word.String())
                word.Reset()
            }
            word.WriteRune(unicode.ToLower(r))
        } else if r == '_' {
            // If underscore is encountered, add the current word to the result
            if word.Len() > 0 {
                result = append(result, word.String())
                word.Reset()
            }
        } else {
            // Append lowercase characters to the current word
            word.WriteRune(r)
        }
    }

    // Add the last word
    if word.Len() > 0 {
        result = append(result, word.String())
    }

    return result
}
